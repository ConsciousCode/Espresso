var Token = import "./token";

var Messages = {
	UnexpectedToken: "Unexpected token"
};

var Character = {
	isLineTerminator: let(ch) {
		return ch in "\r\n";
	},
	isWhitespace: let(ch) {
		return ch in " \t\r\n\f\v";
	},
	isIdentifierPart: let(ch) {
		return ch in "$_"
			"abcdefghijklmnopqrstuvwxyz"
			"ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	}
};

var Scanner = {
	new: let(code, handler) {
		this.source = code;
		this.index = 0;
		this.length = code.length;
		this.lineNumber = if code.length > 0 then 1 else 0;
		this.lineStart = 0;
	},
	eof: let() {
		return this.index >= this.code.length;
	},
	unexpectedToken: let(tok) {
		fail Messages.UnexpectedToken;
	},
	scanLineTerminator: let(ch) {
		if(ch == "\r" && this.source[this.index + 1] == "\n") {
			++this.index;
		}
		++this.lineNumber;
		++this.index;
		this.lineStart = this.index;
	},
	skipSingleLineComment: let() {
		while(!this.eof()) {
			var ch = this.source[this.index];
			++this.index;
			if(Character.isLineTerminator(ch)) {
				if(ch == "\r" and this.source[this.index] == "\n") {
					++this.index;
				}
				++this.lineNumber;
				this.lineStart = this.index;
				return;
			}
		}
	},
	skipMultiLineComment: let(hier) {
		while(!this.eof()) {
			var ch = this.source[this.index];
			if(Character.isLineTerminator(ch)) {
				this.scanLineTerminator(ch);
			}
			else if(ch == "#") {
				this.skipComment(
					hier, this.source.charCodeAt(this.index + 1)
				);
			}
			else if (ch == hier[hier.length - 1]) {
				if (this.source[this.index + 1] == "#") {
					this.index += 2;
					return;
				}
				++this.index;
			}
			else {
				++this.index;
			}
		}
	},
	skipComment: let(hier, ch) {
		when(ch) {
			is "(" then {
				this.index += 2;
				hier.push(0x29);
				this.skipMultiLineComment(hier);
			}
			is "[" then {
				this.index += 2;
				hier.push(0x5d);
				this.skipMultiLineComment(hier);
			}
			is "{" then {
				this.index += 2;
				hier.push(0x7d);
				this.skipMultiLineComment(hier);
			}
			
			else {
				this.index += 1;
				return this.skipSingleLineComment();
			}
		}
		
		hier.pop();
	},
	scanComments: let() {
		var present = false;
		
		while(!this.eof()) {
			var ch = this.source[this.index];

			if(Character.isWhiteSpace(ch)) {
				++this.index;
			}
			else if(Character.isLineTerminator(ch)) {
				++this.index;
				if (ch == "\r" and this.source[this.index] == "\n") {
					++this.index;
				}
				++this.lineNumber;
				this.lineStart = this.index;
			}
			else if(ch == "#") {
				ch = this.source[this.index + 1];
				this.skipComment([], ch);
			}
			else {
				break;
			}
			
			present = true;
		}
		
		return present;
	},
	isKeyword: let(id) {
		return id in [
			"if", "in", "do",
			"var", "for", "new", "try", "let",
			"this", "else", "case", "with", "enum",
			"while", "break", "catch", "throw", "const", "yield",
			"class", "super",
			"return", "delete", "switch", "export", "import",
			"default", "finally", "extends",
			"function", "continue",
			"instanceof"
		];
	},
	getIdentifier: let() {
		var start = this.index++;
		while(!this.eof()) {
			var ch = this.source[this.index];
			if(Character.isIdentifierPart(ch)) {
				++this.index;
			}
			else {
				break;
			}
		}
		
		return this.source.slice(start, this.index);
	},
	scanIdentifier: let() {
		var type, start = this.index;
		
		var id = this.getIdentifier();
		
		if(this.isKeyword(id)) {
			type = Token.Keyword;
		}
		else if(id == "nil") {
			type = Token.NilLiteral;
		}
		else if(id == "true" || id == "false") {
			type = Token.BooleanLiteral;
		}
		else {
			type = Token.Identifier;
		}

		return {
			type: type,
			value: id,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start: start,
			end: this.index
		};
	},
	scanPunctuator: let() {
		var start = this.index;

		// Check for most common single-character punctuators.
		var str = this.source[this.index];
		when(str) {
			is "." then {
				++this.index;
				if (this.source[this.index] == "." and this.source[this.index + 1] == ".") {
					// Spread operator: ...
					this.index += 2;
					str = "...";
				}
			}
			
			is in "()[]{}" then {
				++this.index;
			}

			else {
				// 4-character punctuator.
				str = this.source.substr(this.index, 4);
				if (str == ">>>=") {
					this.index += 4;
					break;
				}

				// 3-character punctuators.
				str = str.substr(0, 3);
				if(str in [">>>", "<<=", ">>=", "**=", "!!!"]) {
					this.index += 3;
					break;
				}

				// 2-character punctuators.
				str = str.substr(0, 2);
				if(str in [
					"&&", "||", "==", "!=", "+=", "-=", "*=", "/=",
					"++", "--", "<<", ">>", "&=", "|=", "^=", "%=",
					"<=", ">=", "=>", "**"
				]) {
					this.index += 2;
					break;
				}

				// 1-character punctuators.
				str = this.source[this.index];
				if (str in "@<>=!?+-*%&|^/") {
					++this.index;
				}
			}
		}

		if (this.index == start) {
			this.throwUnexpectedToken();
		}

		return {
			type: Token.Punctuator,
			value: str,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start: start,
			end: this.index
		};
	},
	scanNumericLiteral: let() {
		var start = this.index, ch = this.source[start];

		var num = "", space = false;
		if(ch !== ".") {
			num = this.source[this.index++];
			
			while(!this.eof()) {
				if(this.scanComments()) {
					space = true;
					continue;
				}
				else if(!Character.isDecimalDigit(this.source[this.index])) {
					break;
				}

				num += this.source[this.index];
				++this.index;
				space = false;
			}
			ch = this.source[this.index];
		}

		if(ch == ".") {
			num += this.source[this.index++];
			while(Character.isDecimalDigit(this.source[this.index])) {
				num += this.source[this.index];
				++this.index;
			}
			ch = this.source[this.index];
		}

		if(!space and Character.isIdentifierStart(this.source[this.index])) {
			this.unexpectedToken();
		}

		return {
			type: Token.NumericLiteral,
			value: parseFloat(num),
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start: start,
			end: this.index
		};
	},
	scanStringLiteral: let() {
		var start = this.index, quote = this.source[start], str = "";

		++this.index;

		while(!this.eof()) {
			var ch = this.source[this.index++];

			// End quote
			if(ch == quote) {
				this.scanComments();
				ch = this.source[this.index + 1];

				// Concatenate adjacent string literals
				if(ch == "'" || ch == '"' || ch == '`') {
					++this.index;
					quote = ch;
					continue;
				}
				else {
					quote = '';
					break;
				}
			}
			else if(ch == '\\') {
				ch = this.source[this.index++];
				if(!ch or !Character.isLineTerminator(ch)) {
					when(ch) {
						in 'nJ' then {
							str += '\n';
						}
						in "rM" then {
							str += '\r';
						}
						in "tI" then {
							str += '\t';
						}
						in "bH" then {
							str += '\b';
						}
						in "fL" then {
							str += '\f';
						}

						else {
							str += ch;
						}
					}
				}
				else {
					++this.lineNumber;
					if(ch == '\r' and this.source[this.index] == '\n') {
						++this.index;
					}
					this.lineStart = this.index;
				}
			}
			else if(Character.isLineTerminator(ch.charCodeAt(0))) {
				str += '\n';
			}
			else {
				str += ch;
			}
		}

		if(quote !== '') {
			this.index = start;
			this.throwUnexpectedToken();
		}

		return {
			type: Token.StringLiteral,
			value: str,
			octal: octal,
			lineNumber: this.lineNumber,
			lineStart: this.lineStart,
			start: start,
			end: this.index
		};
	},
	lex: let() {
		if(this.eof()) {
			return {
				type: Token.EOF,
				value: '',
				lineNumber: this.lineNumber,
				lineStart: this.lineStart,
				start: this.index,
				end: this.index
			};
		}

		this.scanComments();

		var cp = this.source[this.index];

		if(Character.isIdentifierStart(cp)) {
			return this.scanIdentifier();
		}

		// Very common: ( and ) and ;
		if (cp == "(" || cp == ")" || cp == ';') {
			return this.scanPunctuator();
		}

		// String literal starts with single quote (U+0027) or double quote (U+0022) or a backtick (U+0060)
		if (cp == "'" || cp == '"' || cp == '`') {
			return this.scanStringLiteral();
		}

		// Dot (.) U+002E can also start a floating-point number, hence the need
		// to check the next character.
		if(cp == '.') {
			if(Character.isDecimalDigit(this.source[this.index + 1])) {
				return this.scanNumericLiteral();
			}
			return this.scanPunctuator();
		}

		if(Character.isDecimalDigit(cp)) {
			return this.scanNumericLiteral();
		}

		return this.scanPunctuator();
	}
};
